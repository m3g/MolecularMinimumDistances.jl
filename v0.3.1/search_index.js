var documenterSearchIndex = {"docs":
[{"location":"basic/#User-guide","page":"Basic use","title":"User guide","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"Here the usage of the functions that allocate the list of distances will be described. Different running modes are available depending on the expected output.","category":"page"},{"location":"basic/#Installation-and-loading","page":"Basic use","title":"Installation and loading","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"To install MolecularMinimumDistances, first download and install Julia (1.6 or greater) from https://julialang.org/downloads/. Install and run it. Then, use:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> import Pkg; Pkg.add(\"MolecularMinimumDistances\")\n\njulia> using MolecularMinimumDistances","category":"page"},{"location":"basic/#Example-input-files","page":"Basic use","title":"Example input files","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The examples here use a molecular system, but the package actually only considers the coordinates of the atoms and the number of atoms of each molecule. Thus, more general distance problems can be tackled.","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The input of the following tests can be obtained with:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> using PDBTools\n\njulia> system = MolecularMinimumDistances.download_example() \n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026\n","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The system consists of a protein (with 1463 atoms), solvated by 181 TMAO molecules (with 14 atoms each), 19338 water molecules, and some ions. ","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"This is a snapshot of a simulation which was performed with cubic periodic boundary conditions, with a box side of 84.48 Angstrom. We will use periodic boundary conditions in the examples. ","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The coordinates of each of the types of molecules can be extracted from the system array of atoms with (using PDBTools - v0.13 or greater):","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> protein = coor(system,\"protein\")\n1463-element Vector{StaticArrays.SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> tmao = coor(system,\"resname TMAO\")\n2534-element Vector{StaticArrays.SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]\n\njulia> water = coor(system,\"water\")\n58014-element Vector{StaticArrays.SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"Using these vectors of coordinates, we will illustrate the use of the current package.","category":"page"},{"location":"basic/#Shortest-distances-from-a-solute","page":"Basic use","title":"Shortest distances from a solute","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The simplest usage consists of finding for each molecule of one set the atoms of the other set which are closer to them. For example, if we want the atoms of the proteins which are closer to each TMAO molecule (14 atoms), within a cutoff of 12.0 Angstroms, we do:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"note: Note\nIf the solute has more than one molecule, this will not be taken into  consideration in this mode. All molecules will be considered as part of the same structure (the number of atoms per molecule of the protein is not a parameter here).","category":"page"},{"location":"basic/#Without-periodic-boundary-conditions","page":"Basic use","title":"Without periodic boundary conditions","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> list = minimum_distances(tmao, protein, 14, 12.0)\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The list obtained contains, for each molecule of TMAO, a structure of type MinimumDistance, containing:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"A boolean marker, which is true if some protein atom was found within the desired cutoff, false otherwise (field x.within_cutoff).\nThe index of the TMAO atom (field x.i).\nThe index of the protein atom (field x.j).\nThe distance between these atoms (field x.d).","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"For instance, the number of molecules of TMAO having a protein atom within the cutoff are, here:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> count(x -> x.within_cutoff, list)\n33","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"For each molecule of water, he have, similarly:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> list = minimum_distances(water,protein,3,12.)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n\njulia> count(x -> x.within_cutoff, list)\n2251","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"A pictorial representation of this result, for a simpler system, is:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"(Image: solute-solvent)","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"This figure illustrate that all distances between the solute (blue) and the closet atoms of each solvent molecule (red) were found, within the desired cutoff. ","category":"page"},{"location":"basic/#With-periodic-boundary-conditions","page":"Basic use","title":"With periodic boundary conditions","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The example simulation was performed with cubic periodic boundary conditions. Let us provide the box information now. We will exemplify with the calculation of the nearest atoms of the water molecules. The interface here is that define by the Box constructor of CellListMap.jl, described in detail here. General periodic boundary conditions are supported. ","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"The box here is cubic, and we need to provide to the Box constructor the sides and the cutoff:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> box = Box([84.48, 84.48, 84.48], 12.)\nBox{CellListMap.OrthorhombicCell, 3, Float64, Float64, 9}\n  unit cell matrix = [ 84.48, 0.0, 0.0; 0.0, 84.48, 0.0; 0.0, 0.0, 84.48 ]\n  cutoff = 12.0\n  number of computing cells on each dimension = [9, 9, 9]\n  computing cell sizes = [12.06857142857143, 12.06857142857143, 12.06857142857143] (lcell: 1)\n  Total number of cells = 729","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"And the minimum_distance function is called with the box instead of the cutoff:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> list = minimum_distances(water,protein,3,box)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"basic/#All-shortest-distances","page":"Basic use","title":"All shortest distances","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"A similar call of the previous section can be used to compute, for each molecule of a set of molecules, which is the closest atom of every other molecule of another set. ","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"In the example, we can compute for each TMAO molecule, which is the closest atom of water, and vice-versa. The difference from the previous call is that now wee need to provide the number of atoms of both TMAO and water:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> water_list, tmao_list = minimum_distances(water, tmao, 3, 14, box);\n\njulia> water_list\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 1512, 4.779476331147592)\n MinimumDistance{Float64}(true, 6, 734, 2.9413928673334357)\n MinimumDistance{Float64}(true, 8, 859, 5.701548824661595)\n ⋮\n MinimumDistance{Float64}(true, 58010, 1728, 3.942870781549911)\n MinimumDistance{Float64}(true, 58014, 2058, 2.2003220218867936)\n\njulia> tmao_list\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 12, 22520, 2.1985345118965056)\n MinimumDistance{Float64}(true, 20, 33586, 2.1942841657360606)\n MinimumDistance{Float64}(true, 37, 26415, 2.1992319113726926)\n ⋮\n MinimumDistance{Float64}(true, 2512, 37323, 2.198738501959709)\n MinimumDistance{Float64}(true, 2527, 33664, 2.1985044916943015)","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"Two lists were returned, the first containing, for each water molecule, MinimumDistance data associated to the closest TMAO molecule (meaning the atoms involved in the contact and their distance). Similarly, the second list contains, for each TMAO molecule, the MinimumDistance data associated to each TMAO molecule. ","category":"page"},{"location":"basic/#Shortest-distances-within-molecules","page":"Basic use","title":"Shortest distances within molecules","text":"","category":"section"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"There is an interface to compute the shortest distances of molecules within a set of molecules. That is, given one group of molecules, compute for each molecule which is the shortest distance among the other molecules of the same type. ","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"A typical call would be:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"julia> list = minimum_distances(water, 3, box)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 33977, 2.1997806708851724)\n MinimumDistance{Float64}(true, 4, 43684, 2.1994928961012814)\n MinimumDistance{Float64}(true, 9, 28030, 2.1997583958244142)\n ⋮\n MinimumDistance{Float64}(true, 58010, 22235, 2.1992096307537414)\n MinimumDistance{Float64}(true, 58012, 9318, 2.20003227249056)","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"Which contains for each water molecule the atoms involved in the closest contact to any other water molecule, and the distances (within the cutoff). A pictorial representation of a result of this type is, for a simpler system:","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"(Image: self pairs)","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"This can be used for the identification of connectivity networks, for example, or for some types of clustering.","category":"page"},{"location":"basic/","page":"Basic use","title":"Basic use","text":"note: Note\nAll the function accept either a cutoff (a Real value) or a Box in the same argument positions. If the cutoff only is provided, it is assumed that no periodic boundary conditions are used. ","category":"page"},{"location":"advanced/#Advanced-usage","page":"Advanced use","title":"Advanced usage","text":"","category":"section"},{"location":"advanced/#Array-preallocation","page":"Advanced use","title":"Array preallocation","text":"","category":"section"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"The advanced usage of this package exposes the interface of CellListMap, such that it is possible to iterate through sets varying coordinates and perhaps box types without need for reallocating lists of neighbors every time.  ","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Basically, preallocation is needed for:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"The cell lists.\nThe resulting lists of minimum-distances. ","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"And for parallel runs (probably the most common ones):","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Auxiliary arrays for storing threaded versions of the cell lists.\nAuxiliary arrays for storing threaded versions of the resulting lists of minimum-distances. ","category":"page"},{"location":"advanced/#Index-of-molecules","page":"Advanced use","title":"Index of molecules","text":"","category":"section"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Additionally, the low level interface allows the definition of more general groups of particles, in the sense that \"molecule\" can have different number of atoms in the same set. Therefore, one needs to provide a function that returns the index of the molecule of each atom, given the index of the atom. ","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Briefly, if a set of atoms belong to molecules of the same number of atoms, one can compute the index of each molecule using","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"mol_index(i,n) = div((i - 1), n) + 1","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"where i is the atom index in the array of coordinates, and n is the number of atoms per molecule. This is the default assumed in the basic interface, and can be called with:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"julia> using StaticArrays\n\njulia> x = rand(SVector{3,Float64},9); # 3 water molecules\n\njulia> mol_index(2,3) # second atom belongs to first molecule\n1\n\njulia> mol_index(4,3) # fourth atom belongs to second molecule\n2","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Typically, as we will show, this function will be used for setting up molecule indexes.","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"However, more general indexing can be used. For instance, let us suppose that the 9 atoms of the x array of coordinates above belong to 2 molecules, with 4 and 5 indexes each. Then, we could define, for example:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"julia> my_mol_index(i) = i <= 4 ? 1 : 2\nmy_mol_index (generic function with 1 method)\n\njulia> my_mol_index(4)\n1\n\njulia> my_mol_index(5)\n2","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Since the function can close-over an array of molecular indexes, the definition can be completely general, that is:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"julia> molecular_indexes = [ 1, 3, 3, 2, 2, 1, 3, 1, 2 ];\n\njulia> my_mol_index(i) = molecular_indexes[i]\nmy_mol_index (generic function with 1 method)\n\njulia> my_mol_index(1)\n1\n\njulia> my_mol_index(5)\n2","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"In summary, this function that given the index of the atom returns the index of the corresponding molecule must be provided in the advanced interface, and typically will be just a closure around the number of atoms per molecule, using the already available mol_index function. ","category":"page"},{"location":"advanced/#Example","page":"Advanced use","title":"Example","text":"","category":"section"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"The example below illustrates the usage of the interface described above: ","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"using MolecularMinimumDistances\nusing CellListMap # required\nusing PDBTools # example\n\nfunction iterate_lists(nsteps, water, protein)\n    # Load example coordinates\n    # Build initial system and cell lists\n    box = Box([84.48, 84.48, 84.48], 12.)\n    cl = CellList(protein,water,box)\n    # Function that given the index of the atom, returns the index of the molecule. Here, all molecules are similar, and we use the standard `mol_index` function:\n    water_index(i) = mol_index(i,3)\n    # Initialize output array; i -> mol_index(i,3) returns the molecule index for each water molecule\n    list = init_list(water, water_index)\n    # Initalize auxiliary arrays for multi-threading: The number of batches of multi-threading is obtained from a property of the cell-lists (see the CellListMap documentation for additional information and options).\n    aux_cl = CellListMap.AuxThreaded(cl)\n    list_threaded = [ copy(list) for _ in 1:nbatches(cl) ]\n    # Now we are ready to iterate over many possible different sets of coordinates. Here the coordinates or the box won't change, but they could:\n    for i in 1:nsteps\n        # box = Box(...) the box could be redefined here.\n        # Update the cell lists: water and protein coordinates, and box, could change here. \n        cl = UpdateCellList!(water, protein, box, cl, aux_cl)\n        # Update the `list` array:\n        minimum_distances!( water_index, list, box, cl, list_threaded = list_threaded) \n        # Perform whatever futher analysis using the `list` of minimum distances.\n    end\nend\n\n# This function is the driver fro the above example:\nfunction run(nsteps)\n    system = MolecularMinimumDistances.download_example()\n    water = coor(system, \"water\") # water coordinates\n    protein = coor(system, \"protein\") # protein coordinates\n    iterate_lists(nsteps, water, protein)\nend","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Running the above example shows that allocations are small for each iteration:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"julia> using BenchmarkTools\n\njulia> system = MolecularMinimumDistances.download_example();\n\njulia> water = coor(system, \"water\"); # water coordinates\n\njulia> protein = coor(system, \"protein\"); # protein coordinates\n\njulia> @btime iterate_lists(10, $water, $protein)\n  1.113 s (21471 allocations: 36.42 MiB)\n\njulia> @btime iterate_lists(100, $water, $protein)\n  13.568 s (37946 allocations: 38.36 MiB)","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"In fact, if we opted to run the calculation in serial, with:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"function iterate_lists_serial(nsteps, water, protein)\n    box = Box([84.48, 84.48, 84.48], 12.)\n    cl = CellList(protein,water,box, parallel=false)\n    water_index(i) = mol_index(i,3)\n    list = init_list(water, water_index)\n    for i in 1:nsteps\n        cl = UpdateCellList!(water, protein, box, cl, parallel=false)\n        minimum_distances!( water_index, list, box, cl, parallel=false) \n        # Perform whatever futher analysis using the `list` of minimum distances.\n    end\nend","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"We can see that the updating of the cell lists and the computation of the minimum-distance lists are completely allocation free, such that the loop is allocation free:","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"julia> @btime iterate_lists_serial(10, $water, $protein)\n  5.038 s (1925 allocations: 14.43 MiB)\n\njulia> @btime iterate_lists_serial(20, $water, $protein)\n  11.613 s (1955 allocations: 14.43 MiB)","category":"page"},{"location":"advanced/","page":"Advanced use","title":"Advanced use","text":"Thus, using a parallelization scheme at a upper level can be also an alternative.","category":"page"},{"location":"reference/#Citation","page":"Reference","title":"Citation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"If this package was useful, please cite the article describing the main algorithms on which it is based:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"L. Martínez (2022) CellListMap.jl: Efficient and customizable cell list implementation for calculation of pairwise particle properties within a cutoff. https://doi.org/10.48550/arXiv.2202.06427","category":"page"},{"location":"#MolecularMinimumDistances","page":"Home","title":"MolecularMinimumDistances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package computes the minimum distance between molecules, which are represented as arrays of coordinates in two or three dimensions. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To understand the utility and purpose of this package, consider the image below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: nearest.png)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, there is one blue molecule, with 6 atoms, and several red molecules, with 2 atoms each. The package has identified which are the molecules of the red set that have at leat one atom within a cutoff from the atoms of the blue molecule, and annotated the corresponding atoms and the distances.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast cell-list approach, to compute minimum-distance for thousands, or millions of atoms. \nGeneral periodic boundary conditions supported. \nAdvanced mode for in-place calculations, for non-allocating iterative calls (for analysis of MD trajectories, for example).\nModes for the calculation of minimum-distances in sets of molecules.","category":"page"},{"location":"#Most-typical-use:-Understanding-solvation","page":"Home","title":"Most typical use: Understanding solvation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was designed as the backend for computing minimum distance distribution functions, which are useful for understanding solute-solvent interactions when the molecules have complex shapes. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The most typical scenario is that of a protein, or another macromolecule, in a box of solvent. For example, here we download a frame of a protein which was simulated in a mixture of water and TMAO: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using PDBTools\n\njulia> system = MolecularMinimumDistances.download_example()\n   Array{Atoms,1} with 62026 atoms with fields:\n   index name resname chain   resnum  residue        x        y        z  beta occup model segname index_pdb\n       1    N     ALA     A        1        1   -9.229  -14.861   -5.481  0.00  1.00     1    PROT         1\n       2  HT1     ALA     A        1        1  -10.048  -15.427   -5.569  0.00  0.00     1    PROT         2\n       3  HT2     ALA     A        1        1   -9.488  -13.913   -5.295  0.00  0.00     1    PROT         3\n                                                       ⋮ \n   62024  OH2    TIP3     C     9339    19638   13.485   -4.534  -34.438  0.00  1.00     1    WAT2     62024\n   62025   H1    TIP3     C     9339    19638   13.218   -3.647  -34.453  0.00  1.00     1    WAT2     62025\n   62026   H2    TIP3     C     9339    19638   12.618   -4.977  -34.303  0.00  1.00     1    WAT2     62026","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we extract the protein coordinates, and the TMAO coordinates:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> xprot = coor(system,\"protein\")\n1463-element Vector{SVector{3, Float64}}:\n [-9.229, -14.861, -5.481]\n [-10.048, -15.427, -5.569]\n [-9.488, -13.913, -5.295]\n ⋮\n [6.408, -12.034, -8.343]\n [6.017, -10.967, -9.713]\n\njulia> xtmao = coor(system,\"resname TMAO\")\n2534-element Vector{SVector{3, Float64}}:\n [-23.532, -9.347, 19.545]\n [-23.567, -7.907, 19.381]\n [-22.498, -9.702, 20.497]\n ⋮\n [13.564, -16.517, 12.419]\n [12.4, -17.811, 12.052]","category":"page"},{"location":"","page":"Home","title":"Home","text":"The system was simulated with periodic boundary conditions, with sides in this frame of [83.115, 83.044, 83.063], and this information will be provided to the minimum-distance computation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we find all the TMAO molecules having at least one atom closer than 12 Angstroms to the protein, using the current package (TMAO has 14 atoms):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> box = Box([83.115, 83.044, 83.063], 12.);\n\njulia> md = minimum_distances(xtmao, xprot, 14, box)\n181-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(true, 2526, 97, 9.652277658666891)\n\njulia> count(x -> x.within_cutoff, md)\n33","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus, 33 TMAO molecules are within the cutoff distance from the protein, and the distances can be used to study the solvation of the protein.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package exists because this computation is fast. For example, let us choose the water molecules instead, and benchmark the time required to compute these set of distances:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> xwat = coor(system,\"resname TIP3\")\n58014-element Vector{SVector{3, Float64}}:\n [-28.223, 19.92, -27.748]\n [-27.453, 20.358, -27.476]\n [-27.834, 19.111, -28.148]\n ⋮\n [13.218, -3.647, -34.453]\n [12.618, -4.977, -34.303]\n\njulia> using BenchmarkTools\n\njulia> @btime minimum_distances($xwat, $xprot, 3, $box);\n  4.726 ms (2748 allocations: 11.82 MiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compare, a naive algorithm to compute the same thing takes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @btime MolecularMinimumDistances.naive_md($xwat, $xprot, 3, $box);\n  911.580 ms (2 allocations: 604.36 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And the computation can be made faster and in-place using the more advanced interface that allows preallocation of all necessary arrays:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> list = init_list(xwat, i -> mol_index(i,3)); # 3 atoms per molecule\n\njulia> cl = CellList(xwat,xprot,box);\n\njulia> minimum_distances!(i -> mol_index(i,3), list, box, cl)\n19338-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 58011, 383, 10.24673074692606)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Allocations occur only for the launching of multiple threads:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @btime minimum_distances!(\n           $(i -> mol_index(i,3)), \n           $list, $box, $cl, \n           parallel = false\n        );\n  12.723 ms (0 allocations: 0 bytes)\n\njulia> @btime minimum_distances!(\n          $(i -> mol_index(i,3)), \n          $list, $box, $cl,\n          parallel = true # default\n        );\n  3.473 ms (135 allocations: 7.10 MiB)\n","category":"page"},{"location":"#Details-of-the-illustration","page":"Home","title":"Details of the illustration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The initial illustration here consists of a toy solute-solvent example, where the solute is a approximately hexagonal molecule, and the solvent is composed by 40 diatomic molecules. The toy system is built as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MolecularMinimumDistances, StaticArrays\n# x will contain the \"solvent\", composed by 40 diatomic molecules\nx = T[]\ncmin = T(-20,-20)\nfor i in 1:40\n    v = cmin .+ 40*rand(T)\n    push!(x, v)\n    theta = 2pi*rand()\n    push!(x, v .+ T(sin(theta),cos(theta)))\nend\n# y will contain the \"solute\", composed by an approximate hexagonal molecule\ny = [ T(1,1), T(1,-1), T(0,-1.5), T(-1,-1), T(-1,1), T(0,1.5) ]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Next, we compute the minimum distances between each molecule of x (the solvent) and the solute. In the input we need to specify the number of atoms of each molecule in x, and the cutoff up to which we want the distances to be computed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> md = minimum_distances(x,y,2,10.0)\n40-element Vector{MinimumDistance{Float64}}:\n MinimumDistance{Float64}(true, 2, 3, 1.0764931248364737)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n MinimumDistance{Float64}(false, 0, 0, Inf)\n ⋮\n MinimumDistance{Float64}(true, 74, 5, 7.899981412729262)\n MinimumDistance{Float64}(false, 0, 0, Inf)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output is a list of MinimumDistance data structures, one for each molecule in x. The true indicates that a distance smaller than the cutoff was found, and for these the indexes of the atoms in x and y associated are reported, along with the distance between them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this example, from the 40 molecules of x, eleven had atoms closer than the cutoff to some atom of y:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> count(x -> x.within_cutoff, md)\n11","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have an auxiliary function to plot the result, in this case where the \"atoms\" are bi-dimensional:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nimport MolecularMinimumDistances: plot_md!\np = plot(lims=(-20,20),framestyle=:box,grid=false,aspect_ratio=1)\nplot_md!(p, x, 2, y, 6, md, y_cycle=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"will produce the illustration plot above, in which the nearest point between the two sets is identified.","category":"page"}]
}
